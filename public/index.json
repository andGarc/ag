[{"content":"TL;RD The Gestalt principles can be used to understand how people interact with and create order out of visual stimuli.\nThere are 6 principles:\nProximity: Things that are close together are perceived as belonging together.\nSimilarity: Things that look similar are perceived as belonging together.\nContinuity: Our brains prefer to see smooth and continuous paths, even if there are gaps or interruptions.\nClosure: Our brains tend to fill in missing information to create a complete image or object.\nEnclosure: Objects that are enclosed by a boundary are perceived as belonging together.\nConnection: Things that are connected in some way, either by shape or proximity, are perceived as belonging together.\nProximity Basically, things that are close together seem like they belong together.\nThe proximity principle can be very useful in data visualization because it can help make complex data easier to understand. By grouping related data points together, we can create a visual hierarchy and make it easier for the viewer to see patterns and relationships within the data.\nFor example, if we have a scatter plot with many data points, we can use the proximity principle to group data points that are related to each other, such as those that represent the same group or category. We can group related data points together and using color or size. This makes it easier for the viewer to quickly identify clusters of data points and see the patterns within each group.\nSimilarity The similarity principle in Gestalt psychology means that things that look the same seem like they belong together.\nWe can also use the similarity principle to create visual cues that guide the viewer\u0026rsquo;s attention. For example, we can use color or size to highlight data points that are similar to each other, making them stand out from the rest of the data.\nEnclosure The enclosure principle in Gestalt psychology means that when something is surrounded by a boundary, it seems like it belongs together.\nThe enclosure principle can be very useful in data visualization because it can help us to visually organize and group related data points. By enclosing related data points within a boundary, we can create a visual hierarchy that makes it easier for viewers to understand the relationships between the data.\nFor example, in a chart or graph, we can use the enclosure principle to group related data points together. We might draw a box or a circle around a group of data points to show that they are related in some way, such as being part of the same category or group.\nWe can also use the enclosure principle to draw attention to specific data points or groups. By enclosing them within a boundary and using color or other visual cues, we can make them stand out from the rest of the data and draw the viewer\u0026rsquo;s attention to them.\nClosure The closure principle in Gestalt psychology means that our brains like to see things as complete shapes or objects, even if some parts are missing.\nThe closure principle can be very useful in data visualization because it can help us to create a sense of completeness and coherence in our visual representations of data. By using visual elements that suggest completeness, even when parts of the data are missing, we can help viewers to see the patterns and relationships within the data more easily.\nFor example, in a chart or graph, we can use the closure principle to show trends or patterns in the data, even when some data points are missing. We might draw a line or a curve that connects the data points, even if there are gaps in the data, to suggest a complete pattern.\nWe can remove unecessary parts from our graphs and still have our graphs as a cohesive unit, letting out data stand out.\nContinuity Similar closure. The continuity principle in Gestalt psychology means that our brains like to see things in a smooth and continuous way, without abrupt changes or interruptions.\nStripping away unnecessary elements allows out data to stand out more.\nConnection The connection principle in Gestalt psychology means that our brains like to see things that are connected in some way, either by shape or by proximity.\nThe connection principle can be very useful in data visualization because it can help us to create a sense of organization and structure in our visual representations of data. By using visual elements that suggest connection, we can help viewers to see the relationships and patterns within the data more easily.\n","permalink":"http://localhost:1313/ag/posts/gestalt-principles/","summary":"TL;RD The Gestalt principles can be used to understand how people interact with and create order out of visual stimuli.\nThere are 6 principles:\nProximity: Things that are close together are perceived as belonging together.\nSimilarity: Things that look similar are perceived as belonging together.\nContinuity: Our brains prefer to see smooth and continuous paths, even if there are gaps or interruptions.\nClosure: Our brains tend to fill in missing information to create a complete image or object.","title":"Gestalt Principles for Data Visualization"},{"content":"Why use a yaml file When working with Conda a YAML file can be used to list all the necessary packages of your project.\nSteps Make sure Conda is installed To check run conda info Create a YAML file that includes all the packages and versions. You can either create a new one or export one from an existing Conda environment. To export a YAML from an existing environment: conda env_name export \u0026gt; environment.yml name: my_env channels: - defaults dependencies: - numpy=1.18.1 - pandas=1.0.1 - scikit-learn=0.22.1 Create the Conda environment using the YAML file: conda env create -f environment.yml To verify that the environment was created correctly: conda env list Activate your environment! ","permalink":"http://localhost:1313/ag/posts/create-py-env-from-yaml/","summary":"Why use a yaml file When working with Conda a YAML file can be used to list all the necessary packages of your project.\nSteps Make sure Conda is installed To check run conda info Create a YAML file that includes all the packages and versions. You can either create a new one or export one from an existing Conda environment. To export a YAML from an existing environment: conda env_name export \u0026gt; environment.","title":"Python Environment form a YAML file"},{"content":"There are 3 main paths for problem-solving. Which one to chose depends on 2 things:\nHow much clarity there is to the situation How fast you need to deliver the solution The 3 paths to problem solving The Hypothesis-Driven path The Issue-Driven path The Design-Thinking path How to chose the right path If I can\u0026rsquo;t state the problem in a clear and precise way, then I don\u0026rsquo;t understand it properly.\nIf I can\u0026rsquo;t then start with the Design-Driven approach.\nIssue-Driven If I can define the problem, then go with either hypothesis- or the issue-driven path. The issue-driven should be the go to. My default approach is the issue-driven path because it opens up a larger solution space and avoids confirmation biases.\nHypothesis-Driven The goal of the hypothesis-driven path is to confirm or reject a proposed solution. So, I choose this path only in 3 cases:\nI have a potential answer, and it is likely to be the best one. That may be the case when I have deep expertise in the field or somebody has already done a preliminary analysis. The problem is simple, and I recognize a familiar pattern. I don’t have enough time for a more comprehensive issue-driven approach. Working with hypotheses makes sense when you have a good potential solution. It’s appealing because of its strengths:\nIt’s fast and intuitive, saving you time and energy It’s easy to sell because of it’s logic and quickness It can make you look smart (in some circumstances, it’s better to present an idea than to say we don’t know) However, for big problems, it’s risky:\nIt can be misleading when you fall for the expert trap and mistakenly recognize patterns It may frame the problem too narrowly, making you blind to other solutions: What you see is all there is You may communicate a solution before solving the problem, which is dangerous It may lead to a confirmation bias because, psychologically, we are more receptive to information that confirms our beliefs Hence, be mindful and only use this approach in the following cases:\nYou have a deep expertise in the field The problem is simple enough to be recognized as a familiar pattern (be careful of the mentioned traps) You don’t have time for any other solution approach Credit\n","permalink":"http://localhost:1313/ag/posts/problem-solving-for-anyone/","summary":"There are 3 main paths for problem-solving. Which one to chose depends on 2 things:\nHow much clarity there is to the situation How fast you need to deliver the solution The 3 paths to problem solving The Hypothesis-Driven path The Issue-Driven path The Design-Thinking path How to chose the right path If I can\u0026rsquo;t state the problem in a clear and precise way, then I don\u0026rsquo;t understand it properly.","title":"Problem Solving for Anyone"},{"content":"Analyze your queries To see all interactions with the database:\nIn the settings.py add the code below to store all interactions in the sql.log file.\nLOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;file\u0026#39;: { \u0026#39;level: \u0026#39;DEBUG\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;logging.FileHandlers\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;sql.log\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django.db.backends\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;files\u0026#39;], \u0026#39;levels\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;propagate\u0026#39;: \u0026#39;TRUE\u0026#39; } } } Tip 1: Use bulk insert students = [] grades = [] batch_size = 500 for i in range(1000): student = Student() student.first_name = str(i) student.last_name = str(i) students.append(student) Student.objects.bulk_create(students, batch_size) Tip 2: Use bulk update batch_size = 500 grades = Grade.objects.all() for grade in grades: grade.grade = 100 Grade.objects.bulk_update(grades, [**\u0026#39;grade\u0026#39;**], batch_size=batch_size) Tip 3: Preload related object data grades = Grade.objects.select_related(\u0026#34;student\u0026#34;).all() for grade in grades: print(f\u0026#34;The student {grade.student.first_name} has got {grade.grade}%\u0026#34;) Tip 4: Select in bulk ids = [] grades = Grade.objects.all() for grade in grades: if grade.grade == 100: ids.append(grade.student_id) students = Student.objects.in_bulk(ids) for student in students: print(student.first_name, student.last_name) ","permalink":"http://localhost:1313/ag/posts/faster-django-queries/","summary":"Analyze your queries To see all interactions with the database:\nIn the settings.py add the code below to store all interactions in the sql.log file.\nLOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;file\u0026#39;: { \u0026#39;level: \u0026#39;DEBUG\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;logging.FileHandlers\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;sql.log\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django.db.backends\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;files\u0026#39;], \u0026#39;levels\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;propagate\u0026#39;: \u0026#39;TRUE\u0026#39; } } } Tip 1: Use bulk insert students = [] grades = [] batch_size = 500 for i in range(1000): student = Student() student.","title":"Faster Django Queries"},{"content":"Data Types Number BigInt String Boolean Symbol Undefined Null Variables Variables can be defined using let, const, or var.\nlet Block-level variables\nconst Variables whose values are never intended to change. The variable is available from the block it is declared.\nvar Not block-scoped and are discouraged in modern JS code\nOperators + - ** / % ** == === Numbers can be added to strings and vice versa:\n4 + 3 + \u0026#34;5\u0026#34;; // \u0026#34;75\u0026#34; \u0026#34;3\u0026#34; + 4 + 5; // \u0026#34;345\u0026#34; // useful to convert strings Comparision == Does type coercion if given different types\n=== Does not do type coercion if given different types. Preferred.\nControl Structures if and else if () { } else if () { } else { } while do { } while (true) { } for for (let i = 0; i \u0026lt; 5; i++) { // do something } for...of Iterates over iterables (arrays, etc\u0026hellip;)\nfor (conts value of array) { // do something with value } for...in Visits enumerable properties of an object\nfor (const property in object) { //do somthing with object prooerty } switch Based on equality. Comparison takes palce using the === operator.\nswitch (action) { case \u0026#34;draw\u0026#34;: drawit(); break; case \u0026#34;eat\u0026#34;: eat(); break; default: doNothing(); } try..catch Handles errors.\ntry { buildMysite(); } catch (e) { console.error(\u0026#34;Build failed.\u0026#34;, e); } throw Errrors can also be thrown.\nfunction myFunction(a){ if(!a) { throw new Error(\u0026#34;Error\u0026#34;); } } Objects Object can be thought as a collection of key-value pairs. Similar to dictionaries in Python. Properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Keys are always strings or symbols.\nCreate an object const obj = { name: \u0026#34;Carrot\u0026#34;, for: \u0026#34;Max\u0026#34;, details: { color: \u0026#34;orange\u0026#34;, size: 12, }, }; Access properties Properties can be accessed using dot notation or brackets. When using dot notation the key must be a valid identifier. Brackets allow indexing.\n// dot notation obj.name = \u0026#34;Simon\u0026#34;; const name = obj.name; // Bracket notation obj[\u0026#34;name\u0026#34;] = \u0026#34;Simon\u0026#34;; const name = obj[\u0026#34;Simon\u0026#34;]; // Can use a varibale to define a key const userName = prompt(\u0026#34;what is your key?\u0026#34;); obj[\u0026#34;userName\u0026#34;] = prommpt(\u0026#34;what is the value?\u0026#34;); Properties can be chained together.\nobj.details.color; //orange Object are alwats references.\nArrays Array are a special type of object in JS. They have one magical property called lenght.\nCreate array const a = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;]; a.length; //3 Grow or Shrink an array Arrays can grow or shrink\nconst arr = [1, \u0026#34;foo\u0026#34;] arr.push({}) // [1, \u0026#34;foo\u0026#34;, {}] Some array methods map() Applies a callback to every array element and returns a new array.\nconst babies = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;].map((name =\u0026gt; \u0026#39;baby ${name}\u0026#39;)); // babies = [\u0026#34;baby dog\u0026#34;, \u0026#34;baby cat\u0026#34;] Functions Basic function declaration function add(x, y) { const total = x + y; return total; } A function can take 0 or more arguements. The return statement can return a value at any time. If no return stement is used or an empty return with no value is used, then JS returns undefined.\nFunctions parameters do onot have to be specified when calling a function, but:\nParameters that are not set will be set to undefined If you pass more parameters than a funciton expects, the function will ignore the extra parameters Rest paramter systax Similar to **args in Python. Parameters are collected into an array.\nfunction avg(...args) { let sun = 0; for(const item of args) { sum += item; } return sum / args.length.; } avg(2, 3, 5); //3.5 The rest parameter stores all arguments after where it is declared. function avg(firstValue, ...args) will store ther first value passed into firstValue and the remaining in args.\nObject destruction Allows object to be packed and unpacked.\n// use {} braces to decustruct an object function area({w, h}) { return w * h } // {} here create an object console.log(area({w: 3, h: 4})); Default parameters function name(w, h, x=1) { return w * h * x } name(1, 2); //2 instead of NaN Anonymous functions Functions without names. In practice, anonymous functions are typically used as argument to other functions. They are assigned to a variable that can be used to invoke the function.\n// there is no function name const avg = function (...args){ let sum = 0; for (const item of args) { sum += item; } return sum/args.length; }; // function call avg(1,2) Anonymous functions can also be defined by using arrow function expression.\nconst avg = (...args) =\u0026gt; { let sum = 0; for (const item of args) { sum += item; } return sum/args.length; }; Inner functions Nested functions can share variables in their parent.\nClasses Class syntax is similar to Java.\nclass Person { constructor(name) { this.name = name; } sayHello() { return \u0026#39;Hello, I\u0026#39;m ${this.name}.\u0026#39;; } } const p = new Person(\u0026#34;Maria\u0026#34;); console.log(p.sayHello()); Static properties Use static when declaring.\nPrivate properties Use # when declaring.\nAsynchronous programming JS does not support paralleling, only concurrency. There are 3 ways to write asynchronous code:\nCallback-based Promise-based async/await //async/await async function readFile(filename) { const content = await fs.readFile(filename); console.log(content); } Modules import and export statements are used to exchange data between modules.\nimport { foo } from \u0026#34;./foo.js\u0026#34; // unexported variables are local to the module const b = 2; export const a = 1; ","permalink":"http://localhost:1313/ag/posts/js-overview/","summary":"Data Types Number BigInt String Boolean Symbol Undefined Null Variables Variables can be defined using let, const, or var.\nlet Block-level variables\nconst Variables whose values are never intended to change. The variable is available from the block it is declared.\nvar Not block-scoped and are discouraged in modern JS code\nOperators + - ** / % ** == === Numbers can be added to strings and vice versa:\n4 + 3 + \u0026#34;5\u0026#34;; // \u0026#34;75\u0026#34; \u0026#34;3\u0026#34; + 4 + 5; // \u0026#34;345\u0026#34; // useful to convert strings Comparision == Does type coercion if given different types","title":"JS Overview"},{"content":"TL;DR Before version 3.10, Python never had a feature similar to the switch statement in other programming languages Dictionary mapping can be used as a work around Keys act as cases in a switch statement Why did the Python dictionary break up with the JS object?\nBecause the dictionary found the object too \u0026ldquo;undefined\u0026rdquo;\nImplementing a switch case replacement using Python dictionary mapping A switch statement in Java might look like this:\n// switch case to get the string representation of month number int month = 1; String monthString; switch(month) { case 1: month = \u0026#34;January\u0026#34;; break; case 2: month = \u0026#34;February\u0026#34;; break; . . . default: month = \u0026#34;Invalid Month\u0026#34;; break; } System.out.println(\u0026#34;Month \u0026#34; + month + \u0026#34; is \u0026#34; + monthString); // Month 1 is January Python dictionaries contain key:value pairs.\nThe dictionary keys act as cases in a switch statament.\nSwitch case replacement in Python:\n# Function to get the string representation of a month number def month_num_to_string(month): switcher = { 1: \u0026#39;January\u0026#39;, 2: \u0026#39;February\u0026#39;, . . . } # get() returns the value of a key, # otherwise the default value is returned return switcher.get(month, \u0026#39;Invalid Month\u0026#39;) month = 1 print(f\u0026#34;Month #{month} is month_num_to_string(month)}\u0026#34;) # Month 1 is January ","permalink":"http://localhost:1313/ag/posts/switch-in-python/","summary":"TL;DR Before version 3.10, Python never had a feature similar to the switch statement in other programming languages Dictionary mapping can be used as a work around Keys act as cases in a switch statement Why did the Python dictionary break up with the JS object?\nBecause the dictionary found the object too \u0026ldquo;undefined\u0026rdquo;\nImplementing a switch case replacement using Python dictionary mapping A switch statement in Java might look like this:","title":"Switch case replacement in Python"},{"content":"TL;DR The new version of SQLAlchemy has caused a compatibility issue with the read_sql_query() function in pandas. When calling read_sql_query() and utilizing an SQLAlchemy engine to read an SQL query into a DataFrame, an AttributeError is raised. To resolve this error, you can rectify it by enclosing the query string within SQLAlchemy\u0026rsquo;s text() function and passing a connection object instead of an engine object. import pandas as pd from sqlalchemy import create_engine, text engine = create_engine(\u0026#34;\u0026lt;Connection String\u0026gt;\u0026#34;) query = \u0026#34;SELECT * FROM table\u0026#34; df = pd.read_sql_query(text(query), engine.connect()) SQLAlchemy broke! A little while ago, I was trying to read data from an SQL database using SQLAlchemy in Python.\nSQLAlchemy is a Python library that facilitates working with databases using Python code.\nI was attempting to retrieve data from a database by utilizing Pandas\u0026rsquo; read_sql_query() function along with an SQLAlchemy engine.\nimport pandas as pd from sqlalchemy import create_engine engine = create_engine(\u0026#34;connection string\u0026#34;) query = f\u0026#34;SELECT * FROM table\u0026#34; df = pd.read_sql_query(query, engine) I kept getting an AttributeError.\nAttributeError: \u0026#39;OptionEngine\u0026#39; object has no attribute \u0026#39;execute\u0026#39; I felt devastated initially because I am a big fan of SQLAlchemy, and I thought it was no longer compatible with Pandas.\nHowever, my assumption was incorrect. It turned out that the latest version of SQLAlchemy removed the engine.execute() function that the read_sql_query() function in Pandas relied on.\nTo address this issue, I discovered a helpful workaround. I created a TextClause for the SQL query string using SQLAlchemy\u0026rsquo;s text() function. Then, instead of using the engine object, I utilized a connection object.\n# fix import pandas as pd from sqlalchemy import create_engine, text engine = create_engine(\u0026#34;connection string\u0026#34;) query = f\u0026#34;SELECT * FROM table\u0026#34; df = pd.read_sql_query(text(query), engine.connect()) Note: Pandas 2.0.0 is now available, and the recommended fix is actually to upgrade to the latest Pandas version.\n","permalink":"http://localhost:1313/ag/posts/sqlalchemy-broke/","summary":"TL;DR The new version of SQLAlchemy has caused a compatibility issue with the read_sql_query() function in pandas. When calling read_sql_query() and utilizing an SQLAlchemy engine to read an SQL query into a DataFrame, an AttributeError is raised. To resolve this error, you can rectify it by enclosing the query string within SQLAlchemy\u0026rsquo;s text() function and passing a connection object instead of an engine object. import pandas as pd from sqlalchemy import create_engine, text engine = create_engine(\u0026#34;\u0026lt;Connection String\u0026gt;\u0026#34;) query = \u0026#34;SELECT * FROM table\u0026#34; df = pd.","title":"Did SQLAlchemy Break?"},{"content":"Title Expected Behavior Description\nCurrent Behavior Description\nPossible Solution Solution\nSteps to Reproduce (for bugs) See below in Your environment\nYour environment req1 req2 code/step1 code/step2 ","permalink":"http://localhost:1313/ag/posts/issue-reporting-template/","summary":"Title Expected Behavior Description\nCurrent Behavior Description\nPossible Solution Solution\nSteps to Reproduce (for bugs) See below in Your environment\nYour environment req1 req2 code/step1 code/step2 ","title":"Report an issue template"}]