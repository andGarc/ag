[{"content":"Analyze your queries To see all interactions with the database\nIn the settings.py add the code below to store all interactions in the sql.log file.\nLOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;file\u0026#39;: { \u0026#39;level: \u0026#39;DEBUG\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;logging.FileHandlers\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;sql.log\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django.db.backends\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;files\u0026#39;], \u0026#39;levels\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;propagate\u0026#39;: \u0026#39;TRUE\u0026#39; } } } Tip 1: Use bulk insert students = [] grades = [] batch_size = 500 for i in range(1000): student = Student() student.first_name = str(i) student.last_name = str(i) students.append(student) Student.objects.bulk_create(students, batch_size) Tip 2: Use bulk update batch_size = 500 grades = Grade.objects.all() for grade in grades: grade.grade = 100 Grade.objects.bulk_update(grades, [**\u0026#39;grade\u0026#39;**], batch_size=batch_size) Tip 3: Preload related object data grades = Grade.objects.select_related(\u0026#34;student\u0026#34;).all() for grade in grades: print(f\u0026#34;The student {grade.student.first_name} has got {grade.grade}%\u0026#34;) Tip 4: Select in bulk ids = [] grades = Grade.objects.all() for grade in grades: if grade.grade == 100: ids.append(grade.student_id) students = Student.objects.in_bulk(ids) for student in students: print(student.first_name, student.last_name) #python #django\n","permalink":"https://andGarc.github.io/ag/posts/faster-django-queries/","summary":"Analyze your queries To see all interactions with the database\nIn the settings.py add the code below to store all interactions in the sql.log file.\nLOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;file\u0026#39;: { \u0026#39;level: \u0026#39;DEBUG\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;logging.FileHandlers\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;sql.log\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django.db.backends\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;files\u0026#39;], \u0026#39;levels\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;propagate\u0026#39;: \u0026#39;TRUE\u0026#39; } } } Tip 1: Use bulk insert students = [] grades = [] batch_size = 500 for i in range(1000): student = Student() student.","title":"Faster Django Queries"},{"content":"TL;RD The Gestalt principles can be used to understand how people interact with and create order out of visual stimuli.\nThere are 6 principles:\nProximity: Things that are close together are perceived as belonging together.\nSimilarity: Things that look similar are perceived as belonging together.\nContinuity: Our brains prefer to see smooth and continuous paths, even if there are gaps or interruptions.\nClosure: Our brains tend to fill in missing information to create a complete image or object.\nEnclosure: Objects that are enclosed by a boundary are perceived as belonging together.\nConnection: Things that are connected in some way, either by shape or proximity, are perceived as belonging together.\nProximity Basically, things that are close together seem like they belong together.\nThe proximity principle can be very useful in data visualization because it can help make complex data easier to understand. By grouping related data points together, we can create a visual hierarchy and make it easier for the viewer to see patterns and relationships within the data.\nFor example, if we have a scatter plot with many data points, we can use the proximity principle to group data points that are related to each other, such as those that represent the same group or category. We can group related data points together and using color or size. This makes it easier for the viewer to quickly identify clusters of data points and see the patterns within each group.\nSimilarity The similarity principle in Gestalt psychology means that things that look the same seem like they belong together.\nWe can also use the similarity principle to create visual cues that guide the viewer\u0026rsquo;s attention. For example, we can use color or size to highlight data points that are similar to each other, making them stand out from the rest of the data.\nEnclosure The enclosure principle in Gestalt psychology means that when something is surrounded by a boundary, it seems like it belongs together.\nThe enclosure principle can be very useful in data visualization because it can help us to visually organize and group related data points. By enclosing related data points within a boundary, we can create a visual hierarchy that makes it easier for viewers to understand the relationships between the data.\nFor example, in a chart or graph, we can use the enclosure principle to group related data points together. We might draw a box or a circle around a group of data points to show that they are related in some way, such as being part of the same category or group.\nWe can also use the enclosure principle to draw attention to specific data points or groups. By enclosing them within a boundary and using color or other visual cues, we can make them stand out from the rest of the data and draw the viewer\u0026rsquo;s attention to them.\nClosure The closure principle in Gestalt psychology means that our brains like to see things as complete shapes or objects, even if some parts are missing.\nThe closure principle can be very useful in data visualization because it can help us to create a sense of completeness and coherence in our visual representations of data. By using visual elements that suggest completeness, even when parts of the data are missing, we can help viewers to see the patterns and relationships within the data more easily.\nFor example, in a chart or graph, we can use the closure principle to show trends or patterns in the data, even when some data points are missing. We might draw a line or a curve that connects the data points, even if there are gaps in the data, to suggest a complete pattern.\nWe can remove unecessary parts from our graphs and still have our graphs as a cohesive unit, letting out data stand out.\nContinuity Similar closure. The continuity principle in Gestalt psychology means that our brains like to see things in a smooth and continuous way, without abrupt changes or interruptions.\nStripping away unnecessary elements allows out data to stand out more.\nConnection The connection principle in Gestalt psychology means that our brains like to see things that are connected in some way, either by shape or by proximity.\nThe connection principle can be very useful in data visualization because it can help us to create a sense of organization and structure in our visual representations of data. By using visual elements that suggest connection, we can help viewers to see the relationships and patterns within the data more easily.\n","permalink":"https://andGarc.github.io/ag/posts/gestalt-principles/","summary":"TL;RD The Gestalt principles can be used to understand how people interact with and create order out of visual stimuli.\nThere are 6 principles:\nProximity: Things that are close together are perceived as belonging together.\nSimilarity: Things that look similar are perceived as belonging together.\nContinuity: Our brains prefer to see smooth and continuous paths, even if there are gaps or interruptions.\nClosure: Our brains tend to fill in missing information to create a complete image or object.","title":"Gestalt Principles for Data Visualization"},{"content":"Data Types Number BigInt String Boolean Symbol Undefined Null Variables Variables can be defines using let, const, or var.\nlet Block-level variables\nconst Variables whose values are never intended to change. The variable is available from the block it is declared.\nvar Not block-scoped and are discouraged in modern JS code\nOperators + - ** / % ** == === Numbers can be added to strings and vice versa:\n4 + 3 + \u0026#34;5\u0026#34;; // \u0026#34;75\u0026#34; \u0026#34;3\u0026#34; + 4 + 5; // \u0026#34;345\u0026#34; // useful to convert strings Comparision == Does type coercion if given different types\n=== Does not do type coercion if given different types. Preferred.\nControl Structures if and else if () { } else if () { } else { } while do { }while (true) { } for for (let i = 0; i \u0026lt; 5; i++) { } for...of Iterates over iterables (arrays, etc\u0026hellip;)\nfor (conts value of array) { // do something with value } for...in Visits enumerable properties of an object\nfor (const property in object) { //do somthing with object prooerty } switch Based on equality. Comparison takes palce using the === operator.\nswitch (action) { case \u0026#34;draw\u0026#34;: drawit(); break; case \u0026#34;eat\u0026#34;: eat(); break; default: doNothing(); } try..catch Handles errors.\ntry { buildMysite(); } catch (e) { console.error(\u0026#34;Build failed.\u0026#34;, e); } throw Errrors can also be thrown.\nfunction myFunction(a){ if(!a) { throw new Error(\u0026#34;Error\u0026#34;); } } Objects Object can be thought as a collection of key-value pairs. Similar to dictionaries in Python. Properties can be added, deleted, re-ordered, mutated, or dynamically queried at any time. Keys are always strings or symbols.\nCreate an object const obj = { name: \u0026#34;Carrot\u0026#34;, for: \u0026#34;Max\u0026#34;, details: { color: \u0026#34;orange\u0026#34;, size: 12, }, }; Access properties Properties can be accessed using dot notation or brackets. When using dot notation the key must be a valid identifier. Brackets allow indexing.\n// dot notation obj.name = \u0026#34;Simon\u0026#34;; const name = obj.name; // Bracket notation obj[\u0026#34;name\u0026#34;] = \u0026#34;Simon\u0026#34;; const name = obj[\u0026#34;Simon\u0026#34;]; // Can use a varibale to define a key const userName = prompt(\u0026#34;what is your key?\u0026#34;); obj[\u0026#34;userName\u0026#34;] = prommpt(\u0026#34;what is the value?\u0026#34;); Properties can be chained together.\nobj.details.color; //orange Object are alwats references.\nArrays Array are a special type of object in JS. They have one magical property called lenght.\nCreate array const a = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;]; a.length; //3 Grow or Shrink an array Arrays can grow or shrink\nconst arr = [1, \u0026#34;foo\u0026#34;] arr.push({}) // [1, \u0026#34;foo\u0026#34;, {}] Some array methods map() Applies a callback to every array element and returns a new array.\nconst babies = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;].map((name =\u0026gt; \u0026#39;baby ${name}\u0026#39;)); // babies = [\u0026#34;baby dog\u0026#34;, \u0026#34;baby cat\u0026#34;] Functions Basic function declaration function add(x, y) { const total = x + y; return total; } A function can take 0 or more arguements. The return statement can return a value at any time. If no return stement is used or an empty return with no value is used, then JS returns undefined.\nFunctions parameters do onot have to be specified when calling a function, but:\nParameters that are not set will be set to undefined If you pass more parameters than a funciton expects, the function will ignore the extra parameters Rest paramter systax Similar to **args in Python. Parameters are collected into an array.\nfunction avg(...args) { let sun = 0; for(const item of args) { sum += item; } return sum / args.length.; } avg(2, 3, 5); //3.5 The rest parameter stores all arguments after where it is declared. function avg(firstValue, ...args) will store ther first value passed into firstValue and the remaining in args.\nObject destruction Allows object to be packed and unpacked.\n// use {} braces to decustruct an object function area({w, h}) { return w * h } // {} here create an object console.log(area({w: 3, h: 4})); Default parameters function name(w, h, x=1) { return w * h * x } name(1, 2); //2 instead of NaN Anonymous functions Functions without names. In practice, anonymous functions are typically used as argument to other functions. They are assigned to a variable that can be used to invoke the function.\n// there is no function name const avg = function (...args){ let sum = 0; for (const item of args) { sum += item; } return sum/args.length; }; // function call avg(1,2) Anonymous functions can also be defined by using arrow function expression.\nconst avg = (...args) =\u0026gt; { let sum = 0; for (const item of args) { sum += item; } return sum/args.length; }; Inner functions Nested functions can share variables in their parent.\nClasses Class syntax is similar to Java.\nclass Person { constructor(name) { this.name = name; } sayHello() { return \u0026#39;Hello, I\u0026#39;m ${this.name}.\u0026#39;; } } const p = new Person(\u0026#34;Maria\u0026#34;); console.log(p.sayHello()); Static properties Use static when declaring.\nPrivate properties Use # when declaring.\nAsynchronous programming JS does not support paralleling, only concurrency. There are 3 ways to write asynchronous code:\nCallback-based Promise-based async/await //async/await async function readFile(filename) { const content = await fs.readFile(filename); console.log(content); } Modules import and export statements are used to exchange data between modules.\nimport { foo } from \u0026#34;./foo.js\u0026#34; // unexported variables are local to the module const b = 2; export const a = 1; ","permalink":"https://andGarc.github.io/ag/posts/js-overview/","summary":"Data Types Number BigInt String Boolean Symbol Undefined Null Variables Variables can be defines using let, const, or var.\nlet Block-level variables\nconst Variables whose values are never intended to change. The variable is available from the block it is declared.\nvar Not block-scoped and are discouraged in modern JS code\nOperators + - ** / % ** == === Numbers can be added to strings and vice versa:\n4 + 3 + \u0026#34;5\u0026#34;; // \u0026#34;75\u0026#34; \u0026#34;3\u0026#34; + 4 + 5; // \u0026#34;345\u0026#34; // useful to convert strings Comparision == Does type coercion if given different types","title":"JS Overview"}]